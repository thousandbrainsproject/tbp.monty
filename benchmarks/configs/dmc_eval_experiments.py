# ------------------------------------------------------------------------------
# Copyright (C) 2023 Numenta Inc. All rights reserved.
#
# The information and source code contained herein is the
# exclusive property of Numenta Inc. No part of this software
# may be used, reproduced, stored or distributed in any form,
# without explicit written authorization from Numenta Inc.
# ------------------------------------------------------------------------------

"""Evaluation experiments using pretrained models.

This module defines a suite of evaluation experiments using pretrained models
generated by `dmc_pretraining_experiments.py`. The core experiments are
 - `dist_agent_1lm`
 - `surf_agent_1lm`
 - `touch_agent_1lm`
 - `dist_agent_1lm_nohyp`
 - `surf_on_dist`
 - `touch_on_dist`
 - `dist_on_surf`
 - `touch_on_surf`
 - `dist_on_touch`
 - `surf_on_touch`
 - `dist_agent_2lm`
 - `dist_agent_5lm`
 - `dist_agent_9lm`
 - `dist_agent_10lm`

These base experiments test on the same 77 YCB object, 14 rotation scheme used
to pretrain the loaded models. Each of these models may have counterparts with
combinations of noise and random object rotations. For example, for `dist_agent_1lm`,
we also have `dist_agent_1lm_noise` and `dist_agent_1lm_randrot`, and
`dist_agent_1lm_randrot_noise`. Furthermore, each of these has a variant that
evaluates loads the corresponding `_10distinctobj` pretrained model and tests
on the DISTINCT_OBJECTS dataset. These `_10distinctobj` variants are generated
automatically as a convenience. Other variants-creating functions have default
arguments they won't work for every experiment, so noise/randrot variants need to be
created manually.

Some differences between these configs and benchmarks:
 - Unless otherwise specified, they test on all 77 YCB objects.
 - Experiments have 14 epochs, so each object is viewed from 14 angles regardless of
   whether objects are in standard or random rotations.

On style: Unlike `ycb_experiments.py`, this often prefers functions to return configs
over copying and modifying them (for the most part). For example, we have the functions
`get_fc_dist_patch_config()` and `get_fc_surf_patch_config()` which return
default feature-chang esensor module configs.

This approach has two main benefits:

 1. Make settings easier to find. Rather than following a chain of copied configs
    back to find which sensor or learning module an experiment uses, we can just look
    at the function that returns the config. In this way, the functions are an easy
    way to look up defaults.
 - 2. Parameterize configs. This is especially useful when creating multi-LM
    experiments or deleting color information from sensor or learning modules in the
    case of touch-only (no color)experiments.

The config 'getter'functions defined here are
 - `get_dist_evidence_lm_config`
 - `get_surf_evidence_lm_config`
 - `get_fc_dist_patch_config`
 - `get_fc_surf_patch_config`
 - `get_view_finder_config`
 - `get_dist_motor_config`
 - `get_surf_motor_config`

At present, all experiments use `EvidenceGraphLM` learning modules, `FeatureChangeSM`
sensor modules, and goal-state-driven motor systems.

We also have functions to generate experiment variants with sensor noise, random
rotations, or operate on the DISTINCT_OBJECTS dataset.
 - `make_noise_variant`
 - `make_randrot_variant`
 - `make_randrot_noise_variant`
 - `make_10distinctobj_variant`

Note that configs generated with `make_10distinctobj_variant` will load the
pretrained model that has the same name but with the "_10distinctobj" suffix. It
will not load the model trained on all 77 objects.

The variant-producing functions add suffixes to the logging config `run_name`.
For consistency, prefer the following order of suffixes: `_randrot`, `_noise`,
`_10distinctobj`. Other conventions/expectations here:
 - The logging config's `run_name` should be set and match the experiment key.
 - The logging config's `output_dir` should be set to `OUTPUT_DIR`.

This module also has a few conveniences that add to or modify configs.
 - A 10-distinct object variant is automatically generated for every config.
 - Unused (but required) `train_dataloader_class` and `train_dataloader`
   items are added to configs automatically.
 - Experiments are checked to make sure no two configs have the same `output_dir` /
   `run_name` pair to ensure there is no conflict in output paths.
 - Logging can be modified or disabled depending on global variables (see below).

"""

import copy
import os
from pathlib import Path

import numpy as np

from tbp.monty.frameworks.config_utils.config_args import (
    FiveLMMontyConfig,
    MontyArgs,
    MotorSystemConfigCurInformedSurfaceGoalStateDriven,
    MotorSystemConfigInformedGoalStateDriven,
    NineLMMontyConfig,
    ParallelEvidenceLMLoggingConfig,
    PatchAndViewMontyConfig,
    SurfaceAndViewMontyConfig,
    TenLMMontyConfig,
    TwoLMMontyConfig,
    get_cube_face_and_corner_views_rotations,
)
from tbp.monty.frameworks.config_utils.make_dataset_configs import (
    EnvironmentDataloaderPerObjectArgs,
    EvalExperimentArgs,
    FiveLMMountHabitatDatasetArgs,
    NineLMMountHabitatDatasetArgs,
    PatchViewFinderMountHabitatDatasetArgs,
    PredefinedObjectInitializer,
    RandomRotationObjectInitializer,
    SurfaceViewFinderMountHabitatDatasetArgs,
    TenLMMountHabitatDatasetArgs,
    TwoLMMountHabitatDatasetArgs,
)
from tbp.monty.frameworks.environments import embodied_data as ED
from tbp.monty.frameworks.environments.ycb import DISTINCT_OBJECTS, SHUFFLED_YCB_OBJECTS
from tbp.monty.frameworks.experiments import MontyObjectRecognitionExperiment
from tbp.monty.frameworks.loggers.monty_handlers import ReproduceEpisodeHandler
from tbp.monty.frameworks.models.evidence_matching import (
    EvidenceGraphLM,
    MontyForEvidenceGraphMatching,
)
from tbp.monty.frameworks.models.goal_state_generation import (
    EvidenceGoalStateGenerator,
)
from tbp.monty.frameworks.models.sensor_modules import (
    DetailedLoggingSM,
    FeatureChangeSM,
)

# Specify defaults here

# - Logging
PYTHON_LOG_LEVEL = "WARNING"
LOG_WANDB = True
WANDB_GROUP = "dmc"
LOG_REPRODUCE_EPISODES = False
OUTPUT_DIR_STEM = "dmc"  # easy switching to different output dirs

# - Experiment and Monty args
MAX_TOTAL_STEPS = 10_000
MIN_EVAL_STEPS = 20
MAX_EVAL_STEPS = 500


# - Paths
monty_models_dir = os.getenv("MONTY_MODELS")
if not monty_models_dir:
    monty_models_dir = "~/tbp/results/monty/pretrained_models"
PRETRAIN_DIR = Path(monty_models_dir).expanduser() / "pretrained_ycb_dmc"

monty_logs_dir = os.getenv("MONTY_LOGS")
if not monty_logs_dir:
    monty_logs_dir = "~/nta/results/monty"
OUTPUT_DIR = Path(monty_logs_dir).expanduser() / OUTPUT_DIR_STEM
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# - Define testing rotations. Views from enclosing cube faces plus its corners.
TEST_ROTATIONS = get_cube_face_and_corner_views_rotations()

# - Noise settings
DEFAULT_NOISE_PARAMS = dict(
    pose_vectors=2.0,
    hsv=0.1,
    principal_curvatures_log=0.1,
    pose_fully_defined=0.01,
    location=0.002,
)

# ------------------------------------------------------------------------------
# Getter functions for learning modules, sensor modules, and motor configs.
# ------------------------------------------------------------------------------


def get_dist_evidence_lm_config(
    sensor_module_id: str = "patch",
    max_nneighbors: int = 5,
    color: bool = True,
) -> dict:
    """Get default distant evidence learning module config for evaluation.

    Args:
        sensor_module_id: ID of the sensor module this LM is associated with.
        max_nneighbors: Maximum number of neighbors to consider when matching features.
        color: Whether to include color (HSV) features in matching.

    Returns:
        dict: Learning module configuration with EvidenceGraphLM class and arguments
              including matching tolerances, feature weights, and goal state settings.
    """
    out = dict(
        learning_module_class=EvidenceGraphLM,
        learning_module_args=dict(
            max_match_distance=0.01,  # =1cm
            tolerances={
                sensor_module_id: {
                    "hsv": np.array([0.1, 0.2, 0.2]),
                    "principal_curvatures_log": np.ones(2),
                }
            },
            feature_weights={
                sensor_module_id: {
                    "hsv": np.array([1, 0.5, 0.5]),
                }
            },
            # use_multithreading=False,
            # Most likely hypothesis needs to have 20% more evidence than the others
            # to be considered certain enough to trigger a terminal condition (match).
            x_percent_threshold=20,
            # look at 10 closest features stored in the search radius at most.
            max_nneighbors=max_nneighbors,
            # Update all hypotheses with evidence > x_percent_threshold (faster)
            evidence_update_threshold="x_percent_threshold",
            # NOTE: Currently not used when loading pretrained graphs.
            max_graph_size=0.3,  # 30cm
            num_model_voxels_per_dim=100,
            # Goal state generator which is used for model-based action suggestions.
            gsg_class=EvidenceGoalStateGenerator,
            gsg_args=dict(
                # Tolerance(s) when determining goal-state success
                goal_tolerances=dict(
                    location=0.015,  # distance in meters
                ),
                # Number of necessary steps for a hypothesis goal-state to be considered
                min_post_goal_success_steps=5,
                desired_object_distance=0.03,
            ),
        ),
    )
    if not color:
        out["learning_module_args"]["tolerances"][sensor_module_id].pop("hsv")
        out["learning_module_args"]["feature_weights"][sensor_module_id].pop("hsv")

    return out


def get_surf_evidence_lm_config(
    sensor_module_id: str = "patch",
    max_nneighbors: int = 5,
    color: bool = True,
) -> dict:
    """Get default surface evidence learning module config.

    Args:
        sensor_module_id: ID of the sensor module this LM receives input from.
        max_nneighbors: Maximum number of neighbors to consider when matching features.
        color: Whether to include color (HSV) features.

    Returns:
        dict: Learning module config dictionary containing class and args.
    """
    out = dict(
        learning_module_class=EvidenceGraphLM,
        learning_module_args=dict(
            max_match_distance=0.01,  # =1cm
            tolerances={
                sensor_module_id: {
                    "hsv": np.array([0.1, 0.2, 0.2]),
                    "principal_curvatures_log": np.ones(2),
                }
            },
            feature_weights={
                sensor_module_id: {
                    "hsv": np.array([1, 0.5, 0.5]),
                }
            },
            # Most likely hypothesis needs to have 20% more evidence than the others
            # to be considered certain enough to trigger a terminal condition (match).
            x_percent_threshold=20,
            # look at 10 closest features stored in the search radius at most.
            max_nneighbors=max_nneighbors,
            # Update all hypotheses with evidence > x_percent_threshold (faster)
            evidence_update_threshold="x_percent_threshold",
            # NOTE: Currently not used when loading pretrained graphs.
            max_graph_size=0.3,  # 30cm
            num_model_voxels_per_dim=100,
            # Goal state generator which is used for model-based action suggestions.
            gsg_class=EvidenceGoalStateGenerator,
            gsg_args=dict(
                # Tolerance(s) when determining goal-state success
                goal_tolerances=dict(
                    location=0.015,  # distance in meters
                ),
                # Number of necessary steps for a hypothesis goal-state to be considered
                min_post_goal_success_steps=5,
                desired_object_distance=0.025,
            ),
        ),
    )
    if not color:
        out["learning_module_args"]["tolerances"][sensor_module_id].pop("hsv")
        out["learning_module_args"]["feature_weights"][sensor_module_id].pop("hsv")

    return out


def get_fc_dist_patch_config(
    sensor_module_id: str = "patch",
    color: bool = True,
) -> dict:
    """Get default feature-change sensor module config for distant agent.

    Args:
        sensor_module_id (str, optional): ID for the sensor module. Defaults to "patch".
        color (bool, optional): Whether to include color features. Defaults to True.

    Returns:
        dict: Configuration dictionary containing:
            - sensor_module_class: The FeatureChangeSM class
            - sensor_module_args: Dict of arguments including features list,
              delta thresholds, and other sensor module settings
    """
    out = dict(
        sensor_module_class=FeatureChangeSM,
        sensor_module_args=dict(
            sensor_module_id=sensor_module_id,
            features=[
                # morphological features (necessarry)
                "pose_vectors",
                "pose_fully_defined",
                # non-morphological features (optional)
                "on_object",
                "principal_curvatures_log",
                "hsv",
            ],
            delta_thresholds={
                "on_object": 0,
                "distance": 0.01,
            },
            surf_agent_sm=False,
            save_raw_obs=False,
        ),
    )
    if not color:
        out["sensor_module_args"]["features"].remove("hsv")
    return out


def get_fc_surf_patch_config(
    sensor_module_id: str = "patch",
    color: bool = True,
) -> dict:
    """Get default feature-change sensor module config for surface agent.

    Args:
        sensor_module_id (str, optional): ID for the sensor module. Defaults to "patch".
        color (bool, optional): Whether to include color features. Defaults to True.

    Returns:
        dict: Configuration dictionary containing:
            - sensor_module_class: The FeatureChangeSM class
            - sensor_module_args: Dict of arguments including features list,
              delta thresholds, and other sensor module settings
    """
    out = dict(
        sensor_module_class=FeatureChangeSM,
        sensor_module_args=dict(
            sensor_module_id=sensor_module_id,
            features=[
                # morphological features (necessarry)
                "pose_vectors",
                "pose_fully_defined",
                "on_object",
                # non-morphological features (optional)
                "object_coverage",
                "min_depth",
                "mean_depth",
                "principal_curvatures",
                "principal_curvatures_log",
                "hsv",
            ],
            delta_thresholds={
                "on_object": 0,
                "distance": 0.01,
            },
            surf_agent_sm=True,
            save_raw_obs=False,
        ),
    )
    if not color:
        out["sensor_module_args"]["features"].remove("hsv")

    return out


def get_view_finder_config() -> dict:
    """Get default view finder sensor module config for evaluation.

    The view finder sensor module is used to log detailed observations during
    evaluation. It uses the DetailedLoggingSM class with minimal configuration - just
    setting the sensor module ID and disabling raw observation saving.

    Returns:
        dict: Configuration dictionary containing:
            - sensor_module_class: The DetailedLoggingSM class
            - sensor_module_args: Dict with sensor_module_id and save_raw_obs settings
    """
    return dict(
        sensor_module_class=DetailedLoggingSM,
        sensor_module_args=dict(
            sensor_module_id="view_finder",
            save_raw_obs=False,
        ),
    )


def get_dist_motor_config() -> MotorSystemConfigInformedGoalStateDriven:
    """Get default distant motor config for evaluation.

    Returns:
        MotorSystemConfigInformedGoalStateDriven: Motor system configuration for
            distant agents that uses goal states to drive actions.
    """
    return MotorSystemConfigInformedGoalStateDriven()


def get_surf_motor_config() -> MotorSystemConfigCurInformedSurfaceGoalStateDriven:
    """Get default surface motor config for evaluation.

    Returns:
        MotorSystemConfigCurInformedSurfaceGoalStateDriven: Motor system configuration
            for surface agents that uses curvature-informed goal states to drive
            actions.
    """
    return MotorSystemConfigCurInformedSurfaceGoalStateDriven()


"""
Functions used for generating experiment variants.
--------------------------------------------------------------------------------
"""


def make_noise_variant(
    template: dict,
    noise_params: dict = DEFAULT_NOISE_PARAMS,
    color: bool = True,
) -> dict:
    """Duplicate an experiment but with sensor noise.

    Does not add noise to the view finder sensor module.

    Args:
        template: Dictionary containing experiment configuration.
        noise_params: Dictionary of noise parameters to add to sensor modules.
            Defaults to DEFAULT_NOISE_PARAMS.
        color: Whether to include HSV noise parameters. If False, HSV noise is removed.
            Defaults to True.

    Returns:
        dict: Modified experiment config with noise parameters added to sensor modules
            and "_noise" suffix appended to the logging config's run_name.

    Raises:
        ValueError: If experiment config does not have a run name.

    """
    config = copy.deepcopy(template)
    run_name = config["logging_config"].run_name
    if not run_name:
        raise ValueError("Experiment must have a run name to make a noisy version.")

    config["logging_config"].run_name = f"{run_name}_noise"

    noise_params = copy.deepcopy(noise_params)
    if not color:
        noise_params.pop("hsv")

    for sm_dict in config["monty_config"].sensor_module_configs.values():
        sm_args = sm_dict["sensor_module_args"]
        if sm_args["sensor_module_id"] == "view_finder":
            continue
        sm_args["noise_params"] = copy.deepcopy(noise_params)

    return config


def make_randrot_variant(
    template: dict,
) -> dict:
    """Duplicate an experiment but with random object rotations.

    Args:
        template: Dictionary containing experiment configuration.

    Returns:
        dict: Modified experiment config with random rotation object initializer
              and "_randrot" suffix appended to the logging config's run_name.

    Raises:
        ValueError: If experiment config does not have a run name.
    """
    config = copy.deepcopy(template)
    run_name = config["logging_config"].run_name
    if not run_name:
        raise ValueError(
            "Experiment must have a run name to make a random rotation version."
        )
    config["logging_config"].run_name = f"{run_name}_randrot"
    config[
        "eval_dataloader_args"
    ].object_init_sampler = RandomRotationObjectInitializer()

    return config


def make_randrot_noise_variant(
    template: dict,
    noise_params: dict = DEFAULT_NOISE_PARAMS,
    color: bool = True,
) -> dict:
    """Creates a variant of an experiment with both random rotations and sensor noise.

    This is equivalent to `make_noise_variant(make_randrot_variant(config, ...))`
    but not `make_randrot_variant(make_noise_variant(config, ...))` since the latter
    adds suffixes in order. Use this function instead of composing randrot/noise
    functions to ensure naming conventions.

    Args:
        template: Dictionary containing experiment configuration.
        noise_params: Dictionary of noise parameters to add to sensor modules.
            Defaults to DEFAULT_NOISE_PARAMS.
        color: Whether to add noise to color features. Defaults to True.

    Returns:
        dict: Modified experiment config with random rotations, noise parameters,
            and "_randrot_noise" suffix appended to the logging config's run_name.

    """
    config = make_randrot_variant(template)
    config = make_noise_variant(config, noise_params, color=color)

    return config


def make_10distinctobj_variant(template: dict) -> dict:
    """Make 10 distinct object variants for a given config.

    Returns:
        dict: Copy of `template` config that evaluates on DISTINCT_OBJECTS dataset.
            The logging config's `run_name` is appended with "_10distinctobj",
            and the experiment's model path is updated to point to the model trained
            on the DISTINCT_OBJECTS dataset.

    """
    config = copy.deepcopy(template)
    run_name = template["logging_config"].run_name + "_10distinctobj"
    old_model_path = Path(template["experiment_args"].model_name_or_path)
    new_model_path = (
        old_model_path.parent.parent
        / f"{old_model_path.parent.name}_10distinctobj"
        / "pretrained"
    )
    config["logging_config"].run_name = run_name
    config["experiment_args"].model_name_or_path = str(new_model_path)
    config["eval_dataloader_args"].object_names = DISTINCT_OBJECTS
    return config


"""
------------------------------------------------------------------------------
1 LM models
------------------------------------------------------------------------------
"""

dist_agent_1lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "dist_agent_1lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_1lm"),
    monty_config=PatchAndViewMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        sensor_module_configs=dict(
            sensor_module_0=get_fc_dist_patch_config(),
            sensor_module_1=get_view_finder_config(),
        ),
        learning_module_configs=dict(
            learning_module_0=get_dist_evidence_lm_config(),
        ),
        motor_system_config=get_dist_motor_config(),
    ),
    # Set up environment.
    dataset_class=ED.EnvironmentDataset,
    dataset_args=PatchViewFinderMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

surf_agent_1lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "surf_agent_1lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="surf_agent_1lm"),
    monty_config=SurfaceAndViewMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        sensor_module_configs=dict(
            sensor_module_0=get_fc_surf_patch_config(),
            sensor_module_1=get_view_finder_config(),
        ),
        learning_module_configs=dict(
            learning_module_0=get_surf_evidence_lm_config(),
        ),
        motor_system_config=get_surf_motor_config(),
    ),
    # Set up environment.
    dataset_class=ED.EnvironmentDataset,
    dataset_args=SurfaceViewFinderMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

touch_agent_1lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "touch_agent_1lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="touch_agent_1lm"),
    monty_config=SurfaceAndViewMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        sensor_module_configs=dict(
            sensor_module_0=get_fc_surf_patch_config(color=False),
            sensor_module_1=get_view_finder_config(),
        ),
        learning_module_configs=dict(
            learning_module_0=get_surf_evidence_lm_config(color=False),
        ),
        motor_system_config=get_surf_motor_config(),
    ),
    dataset_class=ED.EnvironmentDataset,
    dataset_args=SurfaceViewFinderMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

# Noisy/random rotation variants
# ------------------------------------------------------------------------------

dist_agent_1lm_noise = make_noise_variant(dist_agent_1lm)
dist_agent_1lm_randrot = make_randrot_variant(dist_agent_1lm)
dist_agent_1lm_randrot_noise = make_randrot_noise_variant(dist_agent_1lm)

surf_agent_1lm_noise = make_noise_variant(surf_agent_1lm)
surf_agent_1lm_randrot = make_randrot_variant(surf_agent_1lm)
surf_agent_1lm_randrot_noise = make_randrot_noise_variant(surf_agent_1lm)

touch_agent_1lm_noise = make_noise_variant(touch_agent_1lm, color=False)
touch_agent_1lm_randrot = make_randrot_variant(touch_agent_1lm)
touch_agent_1lm_randrot_noise = make_randrot_noise_variant(touch_agent_1lm, color=False)

"""
------------------------------------------------------------------------------
Non-Hypothesis-Driven Policies
------------------------------------------------------------------------------
"""

dist_agent_1lm_nohyp = copy.deepcopy(dist_agent_1lm)
dist_agent_1lm_nohyp["logging_config"].run_name = "dist_agent_1lm_nohyp"
dist_agent_1lm_nohyp[
    "monty_config"
].motor_system_config.motor_system_args.use_goal_state_driven_actions = False

dist_agent_1lm_nohyp_noise = make_noise_variant(dist_agent_1lm_nohyp)
dist_agent_1lm_nohyp_randrot = make_randrot_variant(dist_agent_1lm_nohyp)
dist_agent_1lm_nohyp_randrot_noise = make_randrot_noise_variant(dist_agent_1lm_nohyp)


"""
------------------------------------------------------------------------------
Multimodal transfer
------------------------------------------------------------------------------
"""

# Trained on distant agent.
surf_on_dist = copy.deepcopy(surf_agent_1lm)
surf_on_dist["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "dist_agent_1lm/pretrained"
)
surf_on_dist["logging_config"].run_name = "surf_on_dist"

touch_on_dist = copy.deepcopy(touch_agent_1lm)
touch_on_dist["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "dist_agent_1lm/pretrained"
)
touch_on_dist["logging_config"].run_name = "touch_on_dist"

# Trained on surface agent.
dist_on_surf = copy.deepcopy(dist_agent_1lm)
dist_on_surf["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "surf_agent_1lm/pretrained"
)
dist_on_surf["logging_config"].run_name = "dist_on_surf"

touch_on_surf = copy.deepcopy(touch_agent_1lm)
touch_on_surf["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "surf_agent_1lm/pretrained"
)
touch_on_surf["logging_config"].run_name = "touch_on_surf"

# Trained on touch agent. Have to remove hsv feature from sensors and learning modules.
dist_on_touch = copy.deepcopy(dist_agent_1lm)
dist_on_touch["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "touch_agent_1lm/pretrained"
)
dist_on_touch["logging_config"].run_name = "dist_on_touch"
dist_on_touch["monty_config"].sensor_module_configs["sensor_module_0"] = (
    get_fc_dist_patch_config(color=False)
)
dist_on_touch["monty_config"].learning_module_configs["learning_module_0"] = (
    get_dist_evidence_lm_config(color=False)
)

# Trained on touch agent. Have to remove hsv feature from sensors and learning modules.
surf_on_touch = copy.deepcopy(surf_agent_1lm)
surf_on_touch["experiment_args"].model_name_or_path = str(
    PRETRAIN_DIR / "touch_agent_1lm/pretrained"
)
surf_on_touch["logging_config"].run_name = "surf_on_touch"
surf_on_touch["monty_config"].sensor_module_configs["sensor_module_0"] = (
    get_fc_surf_patch_config(color=False)
)
surf_on_touch["monty_config"].learning_module_configs["learning_module_0"] = (
    get_surf_evidence_lm_config(color=False)
)

# Noisy/random rotation variants
# ------------------------------------------------------------------------------
surf_on_dist_noise = make_noise_variant(surf_on_dist)
surf_on_dist_randrot = make_randrot_variant(surf_on_dist)
surf_on_dist_randrot_noise = make_randrot_noise_variant(surf_on_dist)

touch_on_dist_noise = make_noise_variant(touch_on_dist, color=False)
touch_on_dist_randrot = make_randrot_variant(touch_on_dist)
touch_on_dist_randrot_noise = make_randrot_noise_variant(touch_on_dist, color=False)

dist_on_surf_noise = make_noise_variant(dist_on_surf)
dist_on_surf_randrot = make_randrot_variant(dist_on_surf)
dist_on_surf_randrot_noise = make_randrot_noise_variant(dist_on_surf)

touch_on_surf_noise = make_noise_variant(touch_on_surf, color=False)
touch_on_surf_randrot = make_randrot_variant(touch_on_surf)
touch_on_surf_randrot_noise = make_randrot_noise_variant(touch_on_surf, color=False)

dist_on_touch_noise = make_noise_variant(dist_on_touch, color=False)
dist_on_touch_randrot = make_randrot_variant(dist_on_touch)
dist_on_touch_randrot_noise = make_randrot_noise_variant(dist_on_touch, color=False)

surf_on_touch_noise = make_noise_variant(surf_on_touch, color=False)
surf_on_touch_randrot = make_randrot_variant(surf_on_touch)
surf_on_touch_randrot_noise = make_randrot_noise_variant(surf_on_touch, color=False)

"""
------------------------------------------------------------------------------
2 LM models
------------------------------------------------------------------------------
"""

dist_agent_2lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "dist_agent_2lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
        min_lms_match=1,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_2lm"),
    monty_config=TwoLMMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        learning_module_configs=dict(
            learning_module_0=get_dist_evidence_lm_config("patch_0"),
            learning_module_1=get_dist_evidence_lm_config("patch_1"),
        ),
        sensor_module_configs=dict(
            sensor_module_0=get_fc_dist_patch_config("patch_0"),
            sensor_module_1=get_fc_dist_patch_config("patch_1"),
            sensor_module_2=get_view_finder_config(),
        ),
        motor_system_config=get_dist_motor_config(),
    ),
    # Set up environment.
    dataset_class=ED.EnvironmentDataset,
    dataset_args=TwoLMMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

dist_agent_2lm_noise = make_noise_variant(dist_agent_2lm)
dist_agent_2lm_randrot = make_randrot_variant(dist_agent_2lm)
dist_agent_2lm_randrot_noise = make_randrot_noise_variant(dist_agent_2lm)

"""
------------------------------------------------------------------------------
5-LM models
------------------------------------------------------------------------------
"""
dist_agent_5lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "dist_agent_5lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
        min_lms_match=3,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_5lm"),
    monty_config=FiveLMMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        learning_module_configs=dict(
            learning_module_0=get_dist_evidence_lm_config("patch_0"),
            learning_module_1=get_dist_evidence_lm_config("patch_1"),
            learning_module_2=get_dist_evidence_lm_config("patch_2"),
            learning_module_3=get_dist_evidence_lm_config("patch_3"),
            learning_module_4=get_dist_evidence_lm_config("patch_4"),
        ),
        sensor_module_configs=dict(
            sensor_module_0=get_fc_dist_patch_config("patch_0"),
            sensor_module_1=get_fc_dist_patch_config("patch_1"),
            sensor_module_2=get_fc_dist_patch_config("patch_2"),
            sensor_module_3=get_fc_dist_patch_config("patch_3"),
            sensor_module_4=get_fc_dist_patch_config("patch_4"),
            sensor_module_5=get_view_finder_config(),
        ),
        motor_system_config=get_dist_motor_config(),
    ),
    # Set up environment.
    dataset_class=ED.EnvironmentDataset,
    dataset_args=FiveLMMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

dist_agent_5lm_noise = make_noise_variant(dist_agent_5lm)
dist_agent_5lm_randrot = make_randrot_variant(dist_agent_5lm)
dist_agent_5lm_randrot_noise = make_randrot_noise_variant(dist_agent_5lm)


"""
9 LM models
--------------------------------------------------------------------------------
"""
dist_agent_9lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "dist_agent_9lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
        min_lms_match=3,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_9lm"),
    monty_config=NineLMMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        learning_module_configs=dict(
            learning_module_0=get_dist_evidence_lm_config("patch_0"),
            learning_module_1=get_dist_evidence_lm_config("patch_1"),
            learning_module_2=get_dist_evidence_lm_config("patch_2"),
            learning_module_3=get_dist_evidence_lm_config("patch_3"),
            learning_module_4=get_dist_evidence_lm_config("patch_4"),
            learning_module_5=get_dist_evidence_lm_config("patch_5"),
            learning_module_6=get_dist_evidence_lm_config("patch_6"),
            learning_module_7=get_dist_evidence_lm_config("patch_7"),
            learning_module_8=get_dist_evidence_lm_config("patch_8"),
        ),
        sensor_module_configs=dict(
            sensor_module_0=get_fc_dist_patch_config("patch_0"),
            sensor_module_1=get_fc_dist_patch_config("patch_1"),
            sensor_module_2=get_fc_dist_patch_config("patch_2"),
            sensor_module_3=get_fc_dist_patch_config("patch_3"),
            sensor_module_4=get_fc_dist_patch_config("patch_4"),
            sensor_module_5=get_fc_dist_patch_config("patch_5"),
            sensor_module_6=get_fc_dist_patch_config("patch_6"),
            sensor_module_7=get_fc_dist_patch_config("patch_7"),
            sensor_module_8=get_fc_dist_patch_config("patch_8"),
            sensor_module_9=get_view_finder_config(),
        ),
        motor_system_config=get_dist_motor_config(),
    ),
    # Set up environment.
    dataset_class=ED.EnvironmentDataset,
    dataset_args=NineLMMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

dist_agent_9lm_noise = make_noise_variant(dist_agent_9lm)
dist_agent_9lm_randrot = make_randrot_variant(dist_agent_9lm)
dist_agent_9lm_randrot_noise = make_randrot_noise_variant(dist_agent_9lm)

"""
10 LM models
--------------------------------------------------------------------------------
"""
dist_agent_10lm = dict(
    experiment_class=MontyObjectRecognitionExperiment,
    experiment_args=EvalExperimentArgs(
        model_name_or_path=str(PRETRAIN_DIR / "dist_agent_10lm/pretrained"),
        n_eval_epochs=len(TEST_ROTATIONS),
        max_total_steps=MAX_TOTAL_STEPS,
        max_eval_steps=MAX_EVAL_STEPS,
        min_lms_match=3,
    ),
    logging_config=ParallelEvidenceLMLoggingConfig(run_name="dist_agent_10lm"),
    monty_config=TenLMMontyConfig(
        monty_class=MontyForEvidenceGraphMatching,
        monty_args=MontyArgs(min_eval_steps=MIN_EVAL_STEPS),
        learning_module_configs=dict(
            learning_module_0=get_dist_evidence_lm_config("patch_0"),
            learning_module_1=get_dist_evidence_lm_config("patch_1"),
            learning_module_2=get_dist_evidence_lm_config("patch_2"),
            learning_module_3=get_dist_evidence_lm_config("patch_3"),
            learning_module_4=get_dist_evidence_lm_config("patch_4"),
            learning_module_5=get_dist_evidence_lm_config("patch_5"),
            learning_module_6=get_dist_evidence_lm_config("patch_6"),
            learning_module_7=get_dist_evidence_lm_config("patch_7"),
            learning_module_8=get_dist_evidence_lm_config("patch_8"),
            learning_module_9=get_dist_evidence_lm_config("patch_9"),
        ),
        sensor_module_configs=dict(
            sensor_module_0=get_fc_dist_patch_config("patch_0"),
            sensor_module_1=get_fc_dist_patch_config("patch_1"),
            sensor_module_2=get_fc_dist_patch_config("patch_2"),
            sensor_module_3=get_fc_dist_patch_config("patch_3"),
            sensor_module_4=get_fc_dist_patch_config("patch_4"),
            sensor_module_5=get_fc_dist_patch_config("patch_5"),
            sensor_module_6=get_fc_dist_patch_config("patch_6"),
            sensor_module_7=get_fc_dist_patch_config("patch_7"),
            sensor_module_8=get_fc_dist_patch_config("patch_8"),
            sensor_module_9=get_fc_dist_patch_config("patch_9"),
            sensor_module_10=get_view_finder_config(),
        ),
        motor_system_config=get_dist_motor_config(),
    ),
    # Set up environment.
    dataset_class=ED.EnvironmentDataset,
    dataset_args=TenLMMountHabitatDatasetArgs(),
    eval_dataloader_class=ED.InformedEnvironmentDataLoader,
    eval_dataloader_args=EnvironmentDataloaderPerObjectArgs(
        object_names=SHUFFLED_YCB_OBJECTS,
        object_init_sampler=PredefinedObjectInitializer(rotations=TEST_ROTATIONS),
    ),
)

dist_agent_10lm_noise = make_noise_variant(dist_agent_10lm)
dist_agent_10lm_randrot = make_randrot_variant(dist_agent_10lm)
dist_agent_10lm_randrot_noise = make_randrot_noise_variant(dist_agent_10lm)


"""
------------------------------------------------------------------------------
Finalize configs
------------------------------------------------------------------------------
"""


CONFIGS = {
    # 1 LM models
    "dist_agent_1lm": dist_agent_1lm,
    "surf_agent_1lm": surf_agent_1lm,
    "touch_agent_1lm": touch_agent_1lm,
    # - noise and randrot versions
    "dist_agent_1lm_noise": dist_agent_1lm_noise,
    "dist_agent_1lm_randrot": dist_agent_1lm_randrot,
    "dist_agent_1lm_randrot_noise": dist_agent_1lm_randrot_noise,
    "surf_agent_1lm_noise": surf_agent_1lm_noise,
    "surf_agent_1lm_randrot": surf_agent_1lm_randrot,
    "surf_agent_1lm_randrot_noise": surf_agent_1lm_randrot_noise,
    "touch_agent_1lm_noise": touch_agent_1lm_noise,
    "touch_agent_1lm_randrot": touch_agent_1lm_randrot,
    "touch_agent_1lm_randrot_noise": touch_agent_1lm_randrot_noise,
    # Non-hypothesis-driven policies
    "dist_agent_1lm_nohyp": dist_agent_1lm_nohyp,
    "dist_agent_1lm_nohyp_noise": dist_agent_1lm_nohyp_noise,
    "dist_agent_1lm_nohyp_randrot": dist_agent_1lm_nohyp_randrot,
    "dist_agent_1lm_nohyp_randrot_noise": dist_agent_1lm_nohyp_randrot_noise,
    # Multimodal transfer
    "surf_on_dist": surf_on_dist,
    "touch_on_dist": touch_on_dist,
    "dist_on_surf": dist_on_surf,
    "touch_on_surf": touch_on_surf,
    "dist_on_touch": dist_on_touch,
    "surf_on_touch": surf_on_touch,
    # - noise and randrot versions
    "surf_on_dist_noise": surf_on_dist_noise,
    "surf_on_dist_randrot": surf_on_dist_randrot,
    "surf_on_dist_randrot_noise": surf_on_dist_randrot_noise,
    "touch_on_dist_noise": touch_on_dist_noise,
    "touch_on_dist_randrot": touch_on_dist_randrot,
    "touch_on_dist_randrot_noise": touch_on_dist_randrot_noise,
    "dist_on_surf_noise": dist_on_surf_noise,
    "dist_on_surf_randrot": dist_on_surf_randrot,
    "dist_on_surf_randrot_noise": dist_on_surf_randrot_noise,
    "touch_on_surf_noise": touch_on_surf_noise,
    "touch_on_surf_randrot": touch_on_surf_randrot,
    "touch_on_surf_randrot_noise": touch_on_surf_randrot_noise,
    "dist_on_touch_noise": dist_on_touch_noise,
    "dist_on_touch_randrot": dist_on_touch_randrot,
    "dist_on_touch_randrot_noise": dist_on_touch_randrot_noise,
    "surf_on_touch_noise": surf_on_touch_noise,
    "surf_on_touch_randrot": surf_on_touch_randrot,
    "surf_on_touch_randrot_noise": surf_on_touch_randrot_noise,
    # Multi-LM models
    "dist_agent_2lm": dist_agent_2lm,
    "dist_agent_2lm_noise": dist_agent_2lm_noise,
    "dist_agent_2lm_randrot": dist_agent_2lm_randrot,
    "dist_agent_2lm_randrot_noise": dist_agent_2lm_randrot_noise,
    "dist_agent_5lm": dist_agent_5lm,
    "dist_agent_5lm_noise": dist_agent_5lm_noise,
    "dist_agent_5lm_randrot": dist_agent_5lm_randrot,
    "dist_agent_5lm_randrot_noise": dist_agent_5lm_randrot_noise,
    "dist_agent_9lm": dist_agent_9lm,
    "dist_agent_9lm_noise": dist_agent_9lm_noise,
    "dist_agent_9lm_randrot": dist_agent_9lm_randrot,
    "dist_agent_9lm_randrot_noise": dist_agent_9lm_randrot_noise,
    "dist_agent_10lm": dist_agent_10lm,
    "dist_agent_10lm_noise": dist_agent_10lm_noise,
    "dist_agent_10lm_randrot": dist_agent_10lm_randrot,
    "dist_agent_10lm_randrot_noise": dist_agent_10lm_randrot_noise,
}

"""
Finalize configs
"""

# Add versions that test on 10distinctobj and use *_10distinctobj pretrained model.
_new_configs = {}
for key, exp in CONFIGS.items():
    _config = make_10distinctobj_variant(exp)
    _new_configs[f"{key}_10distinctobj"] = _config
CONFIGS.update(_new_configs)
del _new_configs, _config


# Perform final checks and attribute assignments.
_output_paths = []
for key, exp in CONFIGS.items():
    # Configure logging.
    exp["logging_config"].output_dir = str(OUTPUT_DIR)
    exp["logging_config"].python_log_level = PYTHON_LOG_LEVEL
    exp["logging_config"].wandb_group = WANDB_GROUP
    if not LOG_WANDB:
        exp["logging_config"].wandb_handlers = []
    if not LOG_REPRODUCE_EPISODES:
        if ReproduceEpisodeHandler in exp["logging_config"].monty_handlers:
            exp["logging_config"].monty_handlers.remove(ReproduceEpisodeHandler)

    # Configure dummy train dataloader. Required but not used.
    exp["train_dataloader_class"] = ED.InformedEnvironmentDataLoader
    exp["train_dataloader_args"] = EnvironmentDataloaderPerObjectArgs(
        object_names=["mug"],
        object_init_sampler=PredefinedObjectInitializer(rotations=[[0, 0, 0]]),
    )

    # CHECK: key must match run_name.
    assert key == exp["logging_config"].run_name

    # CHECK: save destination must be unique.
    _path = Path(exp["logging_config"].output_dir) / exp["logging_config"].run_name
    assert _path not in _output_paths
    _output_paths.append(_path)
del _output_paths, _path
